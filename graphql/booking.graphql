
input SaveBookingInput {
    booking_date: Date
    start_time: String
    end_time: String
    duration: Float
    author_id: ID
    token: String
}
input EmailSubscriptionInput {
    email: String
    token: String
    author_id: ID
}
input SaveFreeBookingInput {
    booking_date: Date
    start_time: String
    end_time: String
    author_id: ID
}

input SaveEmailSubscriptionInput {
    email: String
}

type Booking {
	id: ID
	author: User @belongsTo(relation: "author")
	reader: User @belongsTo(relation: "reader")
    booking_date: Date
    start_time: String
    status : Int
    end_time: String
    created_at: DateTime
}

input saveAuthorUnavailableDateInput {
    unavailable_date: Date
    start_time: String
    end_time: String
    
}

input EditAuthorUnavailableDateInput {
    id: ID
    unavailable_date: Date
    start_time: String
    end_time: String
    
}

type AuthorUnavailableDate{
    id: ID
    unavailable_date: Date
    start_time: String
    end_time: String
    
}

type VideoCallResponse {
    status: String
    jwt_token: String
    room_name: String
    room_sid: String
    message: String
}

type AvailableTime {
    start_time: [String]
    end_time: [String]

}

input CheckAvailableBookingSlotInput {
    date: Date
    start_time: String
    end_time: String
    author_id:ID
}

type CheckAvailableBookingSlotResponse {
    status: String
    message: String
    unavailable_time_slot: [Slot]   
}

type Slot {
    start_time: String
    end_time: String
}

type EmailSubscription {
    user_id: ID
    reader:  User @belongsTo(relation: "user")
    author: User @belongsTo(relation: "author")
    email: String
    charge_amount: String
    created_at: DateTime
}

enum User_Type {
    AUTHOR
    READER
}

